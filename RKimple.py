#This file conains implementation for an genreric RKM method with adaptive b control.
#It contains a seperate implementation for explicit RK methods and DIRK methods 


import numpy as np
from scipy.optimize import fsolve
from OrderCondition import *
import cvxpy as cp
from scipy.optimize import linprog


def setup_LP(solver,rkm,O,rhs,s):
    """
    This method sets up the necesarry variables for the LP Problem
    
    Parameters:
    solver:  solver that should be used
    rkm: RKM used
    O: Order conditin matrix
    s: Number od stages
    
    returns:
    LP_vars Tuple with variables for the LP solver
    
    """
    
    if solver == 'scipy_ip' or solver == 'scipy_sim':
        bounds = (0, None)
        A_eq = np.concatenate((O,-O),axis = 1)
        b_eq = rhs - O@rkm.b
            
        e = np.ones(2*s)
        
        LP_vars = (A_eq,b_eq,e,bounds)
            
    else:
        ap_op =cp.Variable(s)
        an_op =cp.Variable(s)
        e = np.ones(s) #vector for goal Function, just generates the 1-Norm of b
        
        LP_vars = (ap_op,an_op,e,O,rhs)

    return LP_vars

def solve_LP(solver,LP_vars,rkm,u,K,dt,reduce = False,**options):
    """
    This method solves the LP Problem
    
    Parameters:
    
    solver:  a string with the solver that should be used
    LP_vars: the set of variables generated by setup_LP
    
    reduce: If set, the LP problem is first solved with a reduced set of constriants
    
    Returns:
    status: integer representing the status of the algorithm.
      For scipy
        0 : Optimization proceeding nominally.
        1 : Iteration limit reached.
        2 : Problem appears to be infeasible.
        3 : Problem appears to be unbounded.
        4 : Numerical difficulties encountered.
      For cvypy
        0 : Optimization proceeding nominally.
        2 : Problem appears to be infeasible.
        4 : Numerical difficulties encountered.
        5 : solver crashed

    b: found b
    
    """
    
    
                
    if solver == 'scipy_ip' or solver == 'scipy_sim':
        (A_eq,b_eq,e,bounds) = LP_vars
        s = len(rkm.b)
        if solver == 'scipy_ip':
            method = 'interior-point'
        elif solver == 'scipy_sim':
            method = 'revised simplex'
        
        
        if reduce:
            u_ = u+dt*K@rkm.b #A intermediate version of u, if it is >=0 we can use it
            i = np.zeros_like(u,dtype = bool)
            while np.any(u_<0):
                i = (u_<0)|i #update indecies for conditions
                print(np.sum(i),'constraints')
                
                u_slice = u[i] #slice the u and K
                K_slice = K[i,:]
                
                A_ub = np.concatenate((-K_slice,K_slice),axis = 1)
                b_ub = 1/dt*u_slice+K_slice@rkm.b  
                res = linprog(e, A_ub=A_ub, b_ub=b_ub,A_eq=A_eq, b_eq=b_eq, bounds=bounds, method=method,
                              options = options)
                
                b = rkm.b+res.x[:s]-res.x[s:]
                u_ = u+dt*K@b 
                
                if np.any(u_<0) and np.all((u_<0)|i == i): # there are no new conditions
                    print('number of conditions is not increasing')
                    break
      
        else:
            A_ub = np.concatenate((-K,K),axis = 1)
            b_ub = 1/dt*u+K@rkm.b    
            res = linprog(e, A_ub=A_ub, b_ub=b_ub,A_eq=A_eq, b_eq=b_eq, bounds=bounds, method=method,options = options)
        
        
        if res.success:
            b = rkm.b+res.x[:s]-res.x[s:]
            status = 0
        else:
            print('solver did not find solution')
            print('solver_state',res.status)
            status = res.status
            b = rkm.b
            
                    
                    
    else:
        (ap_op,an_op,e,O,rhs) = LP_vars
        
        if reduce:
            u_ = u +dt*K@rkm.b
            i = (u_<0)
            cnt = 0
            while np.any(u_ < 0):
                i = (u_<0)|i #update indecies for conditions
                print(np.sum(i),'constraints')
                
                u_slice = u[i] #slice the u and K
                K_slice = K[i,:]
                
                #solve problem for slices u and K
                prob = cp.Problem(cp.Minimize(e@ap_op+e@an_op),
                [O@(ap_op-an_op+rkm.b)==rhs,u_slice+dt*K_slice@(ap_op-an_op+rkm.b)>=0,ap_op>=0,an_op>=0]) 
                prob.solve(solver=solver,**options)
                b = ap_op.value - an_op.value + rkm.b
                
                u_ = u+dt*K@b
                
                if np.any(u_<0) and np.all((u_<0)|i == i): # there are no new conditions
                    print('number of conditions is not increasing')
                    break
                      
        else:
            prob = cp.Problem(cp.Minimize(e@ap_op+e@an_op),
                [O@(ap_op-an_op+rkm.b)==rhs,u+dt*K@(ap_op-an_op+rkm.b)>=0,ap_op>=0,an_op>=0]) 
            try:
                prob.solve(solver=solver,**options)
            except:
                print('Solver crashed, Replaced b with original b')
                b = rkm.b
                status = 5
                
        if prob.status == cp.OPTIMAL:
            b = ap_op.value - an_op.value + rkm.b
            status = 0
        elif prob.status == cp.OPTIMAL_INACCURATE:
            print(prob.status)
            b = ap_op.value - an_op.value + rkm.b
            status = 4
        else:
            print(prob.status)
            print('Replaced b with original b')
            b = rkm.b
            status = 2


    return (status,b)
    


    
    


def RK_variable_b(rkm, dt, f, w0=[1.,0], t_final=1.,b_fixed = False,solver = cp.ECOS,
                 fallback = True,num_fallback = 1,dumpK=False,verbose=False,LP_opts = {}):
    """    
    Options:
    
        rkm: Base Runge-Kutta method, in Nodepy format
        dt: time step size
        f: RHS of ODE system
        w0: Initial data
        t_final: final solution time        
    """
    
    #setup Variables for Soulution storage
    p = len(w0) #number of dimentions
    
    uu = np.zeros([p,int(t_final/dt)+100])
    uu[:,0] = w0.copy()
    tt = np.zeros([int(t_final/dt)+100])
    
    if dumpK:
        KK = ['null']
    
    
    #Setup Runge Kutta 
    c = rkm.c
    A = rkm.A #has to be lower left triangle
    s = len(c) #number of Stages
    K = np.zeros([p,s])
    
    u = np.array(w0)
    t = 0.
    n = 0
    
    
    if b_fixed == False:
        if fallback == True:
            O, rhs = OrderCond(rkm.A,rkm.c,order = rkm.p-num_fallback) #Fallback
        else:
            O, rhs = OrderCond(rkm.A,rkm.c,order = rkm.p) 
        
        
        LP_vars = setup_LP(solver,rkm,O,rhs,s)
    
          
        
    #for debugging b's    
    bb = np.zeros([s,int(t_final/dt)+2])
        
    #print('set up starting to solve')
    
    #Solve ODE
    while t<t_final:
        for i in range(s):
            #compute Stages
            
                
            #K[:,i] = f(t+c[i]*dt,u+dt*K@A[i,:]) 
            #the 0s in A should make shure that no data from an older Step is used
            
            #Maybe better Approach, because A[i,j] = 0 in many places
            u_prime = u.copy()
            for m in range(i):
                u_prime += dt*A[i,m]*K[:,m]
            
            K[:,i] = f(t+c[i]*dt,u_prime)
            
            if np.any(u_prime<-1.e-5)and verbose: print(n+1,i,u_prime) #print input to f(t,u) if it is negative
            
            #print('intermediatestep computed')
            
        if dumpK:
            KK.append(K.copy())
        
        if b_fixed == False:
            #test if positifity is correct
            if (u+dt*K@rkm.b >= 0).all():
                b =rkm.b
            
            else:
                print('change b',n+1)
                (status,b) = solve_LP(solver,LP_vars,rkm,u,K,dt,**LP_opts)
            #Run Optimisation Problem
            
    
        else:
            b =rkm.b
        #update
        u += dt*K@b
        n += 1
        t += dt
        
        uu[:,n] = u.copy()
        bb[:,n] = b.copy()
        tt[n] = t
        #print('updated')

    if dumpK:
        return (tt[0:n+1],uu[:,0:n+1],bb[:,0:n+1],KK)
    else:
        return (tt[0:n+1],uu[:,0:n+1],bb[:,0:n+1])
        



        
        
#For Implicit Methods

#Define a solver for the equation system 
def solver_Matrix(t,u,dt,a,A,preconditioner = None):
    """ 
    The function solves a equation system of the Form 
    x = f(t,u+dt*a*x)
    and returns x
    where f(t,u)=Au
    """ 
    x = np.linalg.solve(dt*a*A-np.eye(u.size),-A@u)
    #print(max(abs((dt*a*A-np.eye(u.size))@x+A@u)))
    return x
    
    




def solver_nonlinear(t,u,dt,a,f):
    """ 
    The function solves a equation system of the Form 
    x = f(t,u+dt*a*x)
    and returns x
    
    f is a function of t and u
    """ 
    stageeq = lambda x: f(t,u+dt*a*x)-x  # it seems like solving for the argument is better
    x, info, ier, mesg = fsolve(stageeq,u,full_output=1)
    if ier != 1: 
        print(mesg)
    return x

def solver_nonlinear_arg(t,u,dt,a,f,preconditioner=None):
    """ 
    The function solves a equation system of the Form 
    x = f(t,u+dt*a*x)
    and returns x
    
    f is a function of t and u
    
    preconditioner: method for getting a starting point for fsolve (in terms of an y=u_start)
    """ 
    if preconditioner != None:
        y_0 = preconditioner(t,u,dt,a,f)
    else:
        y_0 = u
    
    #print('res orig:',np.linalg.norm(-u+u+dt*a*f(t,u)))
    #print('res new:',np.linalg.norm(-y_0+u+dt*a*f(t,y_0)))
    
    stageeq = lambda y: -y+u+dt*a*f(t,y)   
    y, info, ier, mesg = fsolve(stageeq,y_0,full_output=1)
    
    #check if solution is exact
    if np.any(np.abs(-y+u+dt*a*f(t,y))>0.0001):
        print('stageeq. solved non accurate')
        print(np.linalg.norm(-y+u+dt*a*f(t,y)))
        
    if np.any(u+dt*a*f(t,y)<0):
        print('stageq solved with negative argument')
        print('res:')
        print(max(np.abs(-y+u+dt*a*f(t,y))))
        #print(u+dt*a*f(t,y))
        print('min:')
        print(min(u+dt*a*f(t,y)))
    
    if ier != 1: 
        print(mesg)
    return(f(t,y))
    
    


def RK_variable_b_implicit(rkm, dt, f, w0=[1.,0], t_final=1.,solver_eqs = solver_Matrix,preconditioner = None,
                           b_fixed = False,solver = cp.ECOS,fallback = True,num_fallback = 1,dumpK=False,verbose=False,
                          LP_opts = {}):
    """   
    for Diagonally Implicit methods
    Options:
    
        rkm: Base Runge-Kutta method, in Nodepy format
        dt: time step size, can be a float or a vector of timesteps
        f: Right hand side of ODE in appropiate form for the used solver
        w0: Initial data
        t_final: final solution time     
        solver_eqs: the solver for the apearing equation system of the form x = f(t,u+dt*a*x)
        f: Right hand side of ODE in appropiate form for the used solver
        num_fallback: How many orders the system should be reduced
    """
    
    dt_ = dt
    if isinstance(dt_, (list, tuple, np.ndarray)):
        t_final = sum(dt_)
    
    
    #setup Variables for Soulution storage
    p = len(w0) #number of dimentions
    
    if isinstance(dt_, (list, tuple, np.ndarray)):
        uu = np.zeros([p,dt.size+1])
        uu[:,0] = w0.copy()
        tt = np.zeros([dt.size+1])
    else:
        uu = np.zeros([p,int(t_final/dt)+100])
        uu[:,0] = w0.copy()
        tt = np.zeros([int(t_final/dt)+100])
        
    if dumpK:
        KK = ['null']
    
    #Setup Runge Kutta 
    c = rkm.c
    A = rkm.A #has to be lower left triangle
    s = len(c) #number of Stages
    K = np.zeros([p,s])
    
    u = np.array(w0)
    t = 0.
    n = 0
    
    
    #Setup Optimisation Problem
    if b_fixed == False:
        if fallback == True:
            O, rhs = OrderCond(rkm.A,rkm.c,order = rkm.p-num_fallback) #Fallback
        else:
            O, rhs = OrderCond(rkm.A,rkm.c,order = rkm.p) 
        
        LP_vars = setup_LP(solver,rkm,O,rhs,s)
        
    #for debugging b's  
    if isinstance(dt_, (list, tuple, np.ndarray)):
        bb = np.zeros([s,dt.size+1])
    else:
        bb = np.zeros([s,int(t_final/dt)+100])
        
    #print('set up starting to solve')
    
    #Solve ODE
    while t<t_final:
        if isinstance(dt_, (list, tuple, np.ndarray)): #for adapted stepsizes
            dt = dt_[n]
        if t+dt>t_final:
            dt = t_final-t #MAtch final time exactly
            
        for i in range(s):
            #compute Stages
            
                
            #K[:,i] = f(t+c[i]*dt,u+dt*K@A[i,:]) 
            #the 0s in A should make shure that no data from an older Step is used
            
            #Maybe better Approach, because A[i,j] = 0 in many places
            u_prime = u.copy()
            for m in range(i):
                u_prime += dt*A[i,m]*K[:,m]
            
            K[:,i] = solver_eqs(t+c[i]*dt,u_prime,dt,A[i,i],f,preconditioner=preconditioner)
            
            if np.any(u_prime<-1.e-20)and verbose: print(n+1,i,u_prime) #print input to f(t,u) if it is negative
            #print('intermediatestep computed')
            
        if dumpK:
            KK.append(K.copy())
        
        if b_fixed == False:
            #test if positifity is correct
            if (u+dt*K@rkm.b >= 0).all():
                b =rkm.b
            
            else:
            #Run Optimisation Problem
                print('change b',n+1)
                (status,b) = solve_LP(solver,LP_vars,rkm,u,K,dt,**LP_opts)
                
        else:
            b =rkm.b
        #update
        u += dt*K@b
        t += dt
        n += 1
        
        uu[:,n] = u.copy()
        bb[:,n] = b.copy()
        tt[n] = t
        #print('updated')
       
    if dumpK:
        return (tt[0:n+1],uu[:,0:n+1],bb[:,0:n+1],KK)
    else:
        return (tt[0:n+1],uu[:,0:n+1],bb[:,0:n+1])
    
