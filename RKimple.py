#This file conains implementation for an genreric RKM method with adaptive b control.
#It contains a seperate implementation for explicit RK methods and DIRK methods 


import numpy as np
import scipy.optimize as opt
from OrderCondition import *
import cvxpy as cp
from scipy.optimize import linprog


def setup_LP(solver,rkm,O,rhs,s):
    """
    This method sets up the necesarry variables for the LP Problem
    
    Parameters:
    solver:     solver that should be used
    rkm:        RKM used
    O:          Order condition matrix
    s:          Number od stages
    
    returns:
    LP_vars Tuple with variables for the LP solver
    
    """
    
    if solver == 'scipy_ip' or solver == 'scipy_sim':
        bounds = (0, None)
        A_eq = np.concatenate((O,-O),axis = 1)
        b_eq = rhs - O@rkm.b
            
        e = np.ones(2*s)
        
        LP_vars = (A_eq,b_eq,e,bounds)
            
    else:
        ap_op =cp.Variable(s)
        an_op =cp.Variable(s)
        e = np.ones(s) #vector for goal Function, just generates the 1-Norm of b
        
        LP_vars = (ap_op,an_op,e,O,rhs)

    return LP_vars

def solve_LP(solver,LP_vars,rkm,u,K,dt,reduce = False,verbose_LP = False, **options):
    """
    This method solves the LP Problem
    
    Parameters:
    
    solver:     a string with the solver that should be used
    LP_vars:    the set of variables generated by setup_LP
    
    reduce:     If set, the LP problem is first solved with a reduced set of constriants
    verbose_LP: prints additional messages
    options:    additional Options, are passed through to the used solver
    
    Returns:
    status: integer representing the status of the algorithm.
      For scipy
        0 : Optimization proceeding nominally.
        1 : Iteration limit reached.
        2 : Problem appears to be infeasible.
        3 : Problem appears to be unbounded.
        4 : Numerical difficulties encountered.
      For cvypy
        0 : Optimization proceeding nominally.
        2 : Problem appears to be infeasible.
        4 : Numerical difficulties encountered.
        5 : solver crashed

    b: found b, if solver failed rkm.b
    
    """

    
                
    if solver == 'scipy_ip' or solver == 'scipy_sim':
        (A_eq,b_eq,e,bounds) = LP_vars
        s = len(rkm.b)
        if solver == 'scipy_ip':
            method = 'interior-point'
        elif solver == 'scipy_sim':
            method = 'revised simplex'
        
        
        if reduce:
            u_ = u+dt*K@rkm.b #A intermediate version of u, if it is >=0 we can use it
            i = np.zeros_like(u,dtype = bool)
            while np.any(u_<0):
                i = (u_<0)|i #update indecies for conditions
                if verbose_LP: print(np.sum(i),'constraints')
                
                u_slice = u[i] #slice the u and K
                K_slice = K[i,:]
                
                A_ub = np.concatenate((-K_slice,K_slice),axis = 1)
                b_ub = 1/dt*u_slice+K_slice@rkm.b  
                res = linprog(e, A_ub=A_ub, b_ub=b_ub,A_eq=A_eq, b_eq=b_eq, bounds=bounds, method=method,
                              options = options)
                
                b = rkm.b+res.x[:s]-res.x[s:]
                u_ = u+dt*K@b 
                
                if np.any(u_<0) and np.all((u_<0)|i == i): # there are no new conditions
                    if verbose_LP: print('number of conditions is not increasing')
                    break
      
        else:
            A_ub = np.concatenate((-K,K),axis = 1)
            b_ub = 1/dt*u+K@rkm.b    
            res = linprog(e, A_ub=A_ub, b_ub=b_ub,A_eq=A_eq, b_eq=b_eq, bounds=bounds, method=method,options = options)
        
        
        if res.success:
            b = rkm.b+res.x[:s]-res.x[s:]
            status = 0
        else:
            print('solver did not find solution')
            print('solver_state',res.status)
            status = res.status
            b = rkm.b
            
                    
                    
    else:
        (ap_op,an_op,e,O,rhs) = LP_vars
        
        if reduce:
            u_ = u +dt*K@rkm.b
            i = (u_<0)
            while np.any(u_ < 0):
                i = (u_<0)|i #update indecies for conditions
                if verbose_LP: print(np.sum(i),'constraints')
                
                u_slice = u[i] #slice the u and K
                K_slice = K[i,:]
                
                #solve problem for slices u and K
                prob = cp.Problem(cp.Minimize(e@ap_op+e@an_op),
                        [O@(ap_op-an_op+rkm.b)==rhs,u_slice+dt*K_slice@(ap_op-an_op+rkm.b)>=0,ap_op>=0,an_op>=0]) 
                try:
                    prob.solve(solver=solver,**options)
                    b = ap_op.value - an_op.value + rkm.b
                except:
                    print('Solver crashed, Replaced b with original b')
                    b = rkm.b
                    status = 5

                u_ = u+dt*K@b
                
                if np.any(u_<0) and np.all((u_<0)|i == i): # there are no new conditions
                    if verbose_LP: print('number of conditions is not increasing')
                    break
                      
        else:
            prob = cp.Problem(cp.Minimize(e@ap_op+e@an_op),
                    [O@(ap_op-an_op+rkm.b)==rhs,u+dt*K@(ap_op-an_op+rkm.b)>=0,ap_op>=0,an_op>=0]) 
            try:
                prob.solve(solver=solver,**options)
            except:
                print('Solver crashed, Replaced b with original b')
                b = rkm.b
                status = 5
                
        if prob.status == cp.OPTIMAL:
            b = ap_op.value - an_op.value + rkm.b
            status = 0
        elif prob.status == cp.OPTIMAL_INACCURATE:
            print(prob.status)
            b = ap_op.value - an_op.value + rkm.b
            status = 4
        else:
            print(prob.status)
            print('Replaced b with original b')
            b = rkm.b
            status = 2


    return (status,b)
    


    
    


def RK_variable_b(rkm, dt, f, w0=[1.,0], t_final=1.,b_fixed = False,solver = cp.ECOS,
                 fallback = True,num_fallback = 1,dumpK=False,verbose=False,LP_opts = {}, 
                 return_status = False):

    """    
    Options:
    
        rkm:        Base Runge-Kutta method, in Nodepy format
        dt:         time step size
        f:          RHS of ODE system
        w0:         Initial data
        t_final:    final solution time  
        b_fixed:    if True rkm.b are used
        solver:     the solver used for solving the LP Problem
        fallback:   if True the order of the Order Conditions is reduced by num_fallback
        dumpK:      if True the stage values are also returned
        verbose:    if True function prints additional messages
        return_status: if True the function returns additional messages

    Returns:
        u:      Matrix with the solution
        t:      vector with the times
        b:      Matrix with the used b's

        if dumpK = True:
         K:     Array of the K Matrix containing the stagevalues
        if return_status
         status: dict containing
                'dt': the used dt
                'success': True if solver succeded, False if a inveasible or illdefined LP-Problem occured or the solver crashed
                'message': String containing more details
                'b':       Array with the indecies where b was changed
    """
    
    if not 'verbose_LP' in LP_opts.keys():
        LP_opts['verbose_LP'] = verbose


    #setup Variables for Soulution storage
    p = len(w0) #number of dimentions
    
    uu = np.zeros([p,int(t_final/dt)+100])
    uu[:,0] = w0.copy()
    tt = np.zeros([int(t_final/dt)+100])
    
    
    if dumpK:
        KK = ['null']
    
    
    #Setup Runge Kutta 
    c = rkm.c
    A = rkm.A #has to be lower left triangle
    s = len(c) #number of Stages
    K = np.zeros([p,s])
    
    u = np.array(w0)
    t = 0.
    n = 0
    
    
    if b_fixed == False:
        if fallback == True:
            O, rhs = OrderCond(rkm.A,rkm.c,order = rkm.p-num_fallback) #Fallback
        else:
            O, rhs = OrderCond(rkm.A,rkm.c,order = rkm.p) 
        
        
        LP_vars = setup_LP(solver,rkm,O,rhs,s)
    
          
        
    #for debugging b's    
    bb = np.zeros([s,int(t_final/dt)+2])
        
    status = {
        'dt': dt,
        'success': True,
        'message': '',
        'b':[]
    }
    
    if verbose: print('set up starting to solve')

    while t<t_final:
        for i in range(s):        #compute Stages

            u_prime = u.copy()
            for m in range(i):
                u_prime += dt*A[i,m]*K[:,m]
            
            K[:,i] = f(t+c[i]*dt,u_prime)
            
            if np.any(u_prime<-1.e-5)and verbose: print(n+1,i,u_prime) #print input to f(t,u) if it is negative
            
        if dumpK:
            KK.append(K.copy())
        
        if b_fixed == False:
            #test if positifity is correct
            if (u+dt*K@rkm.b >= 0).all():
                b =rkm.b
            
            else:
                 #Run Optimisation Problem
                if verbose: print('change b',n+1)
                status['b'].append(n+1)
                (status_LP,b) = solve_LP(solver,LP_vars,rkm,u,K,dt,**LP_opts)
                if status_LP in [1,4]:
                    status['message'] = status['message'] + 'LP-solver reported Problem:'+ str(status_LP)+ 'at step' + str(n+1) + '\n'
                elif status_LP in [2,3,5]: 
                     status['success'] = False
                     status['message'] = status['message'] + 'LP-solver failed at step '+ str(n+1) + '\n'
                     break

            
        else:
            b =rkm.b
        #update
        u += dt*K@b
        n += 1
        t += dt
        
        uu[:,n] = u.copy()
        bb[:,n] = b.copy()
        tt[n] = t
        #print('updated')


    ret = (tt[0:n+1],uu[:,0:n+1],bb[:,0:n+1])
    if dumpK:
        ret= ret + (KK,)
    if return_status:
        ret= ret + (status,)
    
    return ret
        



        
        
#For Implicit Methods

#Define a solver for the equation system 
def solver_Matrix(t,u,dt,a,A,preconditioner = None,verbose_solver = False):
    """ 
    The function solves a equation system of the Form 
    x = f(t,u+dt*a*x)
    and returns x
    where f(t,u)=Au
    """ 
    x = np.linalg.solve(dt*a*A-np.eye(u.size),-A@u)
    #print(max(abs((dt*a*A-np.eye(u.size))@x+A@u)))
    return x
    
    




def solver_nonlinear(t,u,dt,a,f,verbose_solver = False):
    """ 
    The function solves a equation system of the Form 
    x = f(t,u+dt*a*x)
    and returns x
    
    f is a function of t and u
    """ 
    stageeq = lambda x: f(t,u+dt*a*x)-x  # it seems like solving for the argument is better
    x, info, ier, mesg = opt.fsolve(stageeq,u,full_output=1)
    if ier != 1: 
        print(mesg)
    return x

def solver_nonlinear_arg(t,u,dt,a,f,verbose_solver = False,preconditioner=None):
    """ 
    The function solves a equation system of the Form 
    x = f(t,u+dt*a*x)
    and returns x
    
    f is a function of t and u
    
    preconditioner: method for getting a starting point for fsolve (in terms of an y=u_start)
    """ 
    if preconditioner != None:
        y_0 = preconditioner(t,u,dt,a,f)
    else:
        y_0 = u
    
    #print('res orig:',np.linalg.norm(-u+u+dt*a*f(t,u)))
    #print('res new:',np.linalg.norm(-y_0+u+dt*a*f(t,y_0)))
    
    stageeq = lambda y: -y+u+dt*a*f(t,y)   
    y, info, ier, mesg = opt.fsolve(stageeq,y_0,full_output=1)
    
    #check if solution is exact
    if np.any(np.abs(-y+u+dt*a*f(t,y))>0.0001):
        print('stageeq. solved non accurate')
        print(np.linalg.norm(-y+u+dt*a*f(t,y)))
        
    if np.any(u+dt*a*f(t,y)<0) and verbose_solver or np.any(u+dt*a*f(t,y)<-1e-8) :
        print('stageq solved with negative argument')
        print('res:')
        print(max(np.abs(-y+u+dt*a*f(t,y))))
        #print(u+dt*a*f(t,y))
        print('min:')
        print(min(u+dt*a*f(t,y)))
    
    if ier != 1: 
        print(mesg)
    return(f(t,y))
    
def solver_nonlinear_nk(t,u,dt,a,f,verbose_solver = False,preconditioner=None):
    """ 
    The function solves a equation system of the Form 
    x = f(t,u+dt*a*x)
    and returns x
    
    f is a function of t and u
    
    The method uses the Newton-Krylov solver from scipy
    """ 
    if preconditioner != None:
        y_0 = preconditioner(t,u,dt,a,f)
    else:
        y_0 = u
    
    #print('res orig:',np.linalg.norm(-u+u+dt*a*f(t,u)))
    #print('res new:',np.linalg.norm(-y_0+u+dt*a*f(t,y_0)))
    
    stageeq = lambda y: -y+u+dt*a*f(t,y)  
    
    y = opt.newton_krylov(stageeq,y_0)
    
    #check if solution is exact
    if np.any(np.abs(-y+u+dt*a*f(t,y))>1e-10):
        print('stageeq. solved non accurate')
        print(np.linalg.norm(-y+u+dt*a*f(t,y)))
        
    if np.any(u+dt*a*f(t,y)<0) and verbose_solver or np.any(u+dt*a*f(t,y)<-1e-8) :
        print('stageq solved with negative argument')
        print('res:')
        print(max(np.abs(-y+u+dt*a*f(t,y))))
        #print(u+dt*a*f(t,y))
        print('min:')
        print(min(u+dt*a*f(t,y)))
        
    return(f(t,y))


def RK_variable_b_implicit(rkm, dt, f, w0=[1.,0], t_final=1.,solver_eqs = solver_Matrix,
                           b_fixed = False,solver = cp.ECOS,fallback = True,num_fallback = 1,dumpK=False,verbose=False,
                          LP_opts = {},solveropts = {},return_status = False):
    """   
    for Diagonally Implicit methods
    Options:
    
        rkm:        Base Runge-Kutta method, in Nodepy format
        dt:         time step size, can be a float or a vector of timesteps
        f:          Right hand side of ODE in appropiate form for the used solver
        w0:         Initial data
        t_final:    final solution time    
        b_fixed:    if True rkm.b are used 
        solver_eqs: the solver for the apearing equation system of the form x = f(t,u+dt*a*x)
        solver:     the solver used for solving the LP Problem
        fallback:   if True the order of the Order Conditions is reduced by num_fallback
        dumpK:      if True the stage values are also returned
        verbose:    if True function prints additional messages
        return_status: if True the function returns additional messages

    Returns:
        u:      Matrix with the solution
        t:      vector with the times
        b:      Matrix with the used b's

        if dumpK = True:
         K:         Array of the K Matrix containing the stagevalues
        if return_status
         status:    dict containing
                'dt':       the used dt
                'success':  True if solver succeded, False if a inveasible or illdefined LP-Problem occured or the solver crashed
                'message':  String containing more details
                'b':        Array with the indecies where b was changed
    """

    
    
    dt_ = dt
    if isinstance(dt_, (list, tuple, np.ndarray)):
        t_final = sum(dt_)
    
    if not 'verbose_LP' in LP_opts.keys():
        LP_opts['verbose_LP'] = verbose

    
    
    #setup Variables for Soulution storage
    p = len(w0) #number of dimentions
    
    if isinstance(dt_, (list, tuple, np.ndarray)):
        uu = np.zeros([p,dt.size+1])
        uu[:,0] = w0.copy()
        tt = np.zeros([dt.size+1])
    else:
        uu = np.zeros([p,int(t_final/dt)+100])
        uu[:,0] = w0.copy()
        tt = np.zeros([int(t_final/dt)+100])
        
    if dumpK:
        KK = ['null']
    
    #Setup Runge Kutta 
    c = rkm.c
    A = rkm.A #has to be lower left triangle
    s = len(c) #number of Stages
    K = np.zeros([p,s])
    
    u = np.array(w0)
    t = 0.
    n = 0
    
    
    #Setup Optimisation Problem
    if b_fixed == False:
        if fallback == True:
            O, rhs = OrderCond(rkm.A,rkm.c,order = rkm.p-num_fallback) #Fallback
        else:
            O, rhs = OrderCond(rkm.A,rkm.c,order = rkm.p) 
        
        LP_vars = setup_LP(solver,rkm,O,rhs,s)
        
    #for debugging b's  
    if isinstance(dt_, (list, tuple, np.ndarray)):
        bb = np.zeros([s,dt.size+1])
    else:
        bb = np.zeros([s,int(t_final/dt)+100])

    status = {
        'dt': dt,
        'success': True,
        'message': '',
        'b':[]
    }

        
    if verbose: print('set up starting to solve')
    
    #Solve ODE
    while t<t_final:
        if isinstance(dt_, (list, tuple, np.ndarray)): #for adapted stepsizes
            dt = dt_[n]
        if t+dt>t_final:
            dt = t_final-t #MAtch final time exactly
            
        for i in range(s): #compute Stages               
            u_prime = u.copy() 
            for m in range(i):
                u_prime += dt*A[i,m]*K[:,m]
            
            K[:,i] = solver_eqs(t+c[i]*dt,u_prime,dt,A[i,i],f,**solveropts)
            
            if np.any(u_prime<-1.e-20)and verbose: print(n+1,i,u_prime) #print input to f(t,u) if it is negative
            #print('intermediatestep computed')
            
        if dumpK:
            KK.append(K.copy())
        
        if b_fixed == False:
            #test if positifity is correct
            if (u+dt*K@rkm.b >= 0).all():
                b =rkm.b
            
            else:
                 #Run Optimisation Problem
                if verbose: print('change b',n+1)
                status['b'].append(n+1)
                (status_LP,b) = solve_LP(solver,LP_vars,rkm,u,K,dt,**LP_opts)
                if status_LP in [1,4]:
                    status['message'] = status['message'] + 'LP-solver reported Problem:'+ str(status_LP)+ 'at step' + str(n+1) + '\n'
                elif status_LP in [2,3,5]: 
                     status['success'] = False
                     status['message'] = status['message'] + 'LP-solver failed at step '+ str(n+1) + '\n'
                     break

        else:
            b =rkm.b
        #update
        u += dt*K@b
        t += dt
        n += 1
        
        uu[:,n] = u.copy()
        bb[:,n] = b.copy()
        tt[n] = t
        #print('updated')
       
    ret = (tt[0:n+1],uu[:,0:n+1],bb[:,0:n+1])
    if dumpK:
        ret = ret + (KK,)
    if return_status:
        ret = ret + (status,)
    
    return ret
